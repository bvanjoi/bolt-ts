use bolt_ts_atom::AtomId;
use bolt_ts_fs::CachedFileSystem;
use bolt_ts_fs::PathId;
use bolt_ts_utils::path::NormalizePath;
use std::path::Path;

use super::Extensions;
use super::RResult;
use super::normalize_join::normalize_join;
use super::package_json::PackageJsonInfoId;
use super::resolution_kind_spec_loader::ResolutionKindSpecLoader;

pub struct Loader {
    rest_idx: Option<usize>,
    package_info: Option<PackageJsonInfoId>,
}

impl<FS: bolt_ts_fs::CachedFileSystem> ResolutionKindSpecLoader<'_, FS> for Loader {
    fn loader(
        &self,
        resolver: &super::Resolver<FS>,
        ext: Extensions,
        candidate: &mut std::path::PathBuf,
        only_record_failures: bool,
    ) -> RResult<PathId> {
        let path_and_extension = resolver
            .load_module_from_file(ext, candidate, only_record_failures)
            .or_else(|_| {
                resolver.load_node_module_from_dir_worker(
                    ext,
                    candidate,
                    only_record_failures,
                    self.package_info,
                )
            });
        if path_and_extension.is_err()
            && self.rest_idx.is_none()
            && self.package_info.is_some_and(|_| false)
        {
            todo!()
        }
        path_and_extension
    }
}

impl<FS: CachedFileSystem> super::Resolver<FS> {
    pub(super) fn load_module_from_spec_node_modules_dir(
        &self,
        ext: Extensions,
        node_module_dir: PathId,
        module_name: AtomId,
        node_module_dir_exist: bool,
    ) -> RResult<PathId> {
        let mut atoms = self.atoms.lock().unwrap();
        let dir = Path::new(atoms.get(node_module_dir.into()));
        debug_assert!(dir.is_normalized());
        let name = atoms.get(module_name);
        let rest_idx = super::parse_package_name::split_slash_for_package_name(name);
        let mut candidate = normalize_join(dir, name);
        debug_assert!(candidate.is_normalized());
        let bytes = candidate.as_os_str().as_encoded_bytes();
        let s = unsafe { std::str::from_utf8_unchecked(bytes) };
        let candidate_id = atoms.atom(s).into();
        // let pkg_dir = if let Some(rest_idx) = rest_idx {
        //     normalize_join(dir, &name[..rest_idx])
        // } else {
        //     normalize_join(dir, name)
        // };
        drop(atoms);
        let package_info = self.get_pkg_json_info(candidate_id, !node_module_dir_exist);
        // if let Some(rest_idx) = rest_idx {
        //     todo!()
        // }
        let loader = Loader {
            rest_idx,
            package_info,
        };
        loader.loader(self, ext, &mut candidate, !node_module_dir_exist)
    }
}
